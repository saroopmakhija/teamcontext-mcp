#!/usr/bin/env python3
"""
MCP Server for project and context management.
Extracts auth token from request headers for per-request authentication.
"""
from fastmcp import FastMCP
from fastmcp.server.dependencies import get_http_headers
from typing import List, Optional
import api

mcp = FastMCP("Context Manager")


def get_auth_token() -> str:
    """Extract auth token from HTTP headers"""
    # get_http_headers() returns a dict of all headers
    headers = get_http_headers()
    
    # Try both capitalized and lowercase (HTTP headers are case-insensitive)
    auth_header = headers.get("Authorization") or headers.get("authorization")
    
    if not auth_header:
        print(f"‚ùå No Authorization header found. Available headers: {list(headers.keys())}")
        raise Exception("No Authorization header found")
    
    # Extract token from "Bearer <token>" format
    if isinstance(auth_header, str) and auth_header.startswith("Bearer "):
        token = auth_header[7:]  # Remove "Bearer " prefix
        print(f"üîë Using auth token: {token[:10]}...")
        return token
    else:
        raise Exception(f"Invalid Authorization header format. Expected 'Bearer <token>', got: {auth_header}")


@mcp.tool()
def get_me() -> str:
    """
    Get current authenticated user info.
    
    Returns:
        Formatted user information
    """
    try:
        auth_token = get_auth_token()
        user = api.get_me(auth_token)
        
        output = f"‚úÖ Authenticated User:\n"
        output += f"ID: {user.get('id')}\n"
        output += f"Name: {user.get('name')}\n"
        output += f"Email: {user.get('email')}\n"
        return output
    except Exception as e:
        return f"‚ùå Failed to get user info: {str(e)}"


@mcp.tool()
def add_project(name: str, description: str) -> str:
    """
    Create a new project.
    
    Args:
        name: Project name
        description: Project description
    
    Returns:
        Success message with project ID
    """
    try:
        auth_token = get_auth_token()
        result = api.add_project(auth_token, name, description)
        return f"‚úÖ Project created successfully!\nProject ID: {result['id']}\nName: {result['name']}"
    except Exception as e:
        return f"‚ùå Failed to create project: {str(e)}"


@mcp.tool()
def get_all_projects() -> str:
    """
    Get all projects the user owns or contributes to.
    
    Returns:
        Formatted list of all projects
    """
    try:
        auth_token = get_auth_token()
        projects = api.get_all_projects(auth_token)
        
        if not projects:
            return "No projects found. Create one with add_project!"
        
        output = f"üìÅ Found {len(projects)} project(s):\n\n"
        for i, proj in enumerate(projects, 1):
            output += f"{i}. {proj['name']}\n"
            output += f"   ID: {proj['id']}\n"
            output += f"   Description: {proj['description']}\n"
            output += f"   Owner: {proj['owner_name']}\n"
            
            if proj.get('contributors'):
                contrib_names = [c['name'] for c in proj['contributors']]
                output += f"   Contributors: {', '.join(contrib_names)}\n"
            
            output += "\n"
        
        return output
    except Exception as e:
        return f"‚ùå Failed to get projects: {str(e)}"


@mcp.tool()
def edit_project(
    project_id: str,
    name: Optional[str] = None,
    description: Optional[str] = None
) -> str:
    """
    Update a project's name and/or description.
    
    Args:
        project_id: ID of the project to update
        name: New project name (optional)
        description: New project description (optional)
    
    Returns:
        Success message with updated project info
    """
    try:
        if not name and not description:
            return "‚ùå Must provide at least name or description to update"
        
        auth_token = get_auth_token()
        result = api.edit_project(auth_token, project_id, name, description)
        return f"‚úÖ Project updated successfully!\nName: {result['name']}\nDescription: {result['description']}"
    except Exception as e:
        return f"‚ùå Failed to update project: {str(e)}"


@mcp.tool()
def add_context(
    content: str,
    project_id: str,
    source: Optional[str] = None
) -> str:
    """
    Add context/information to a project. The content will be embedded and stored for later retrieval.
    Tags are automatically generated by finding the top 3 most similar chunks in the project (similarity >= 0.01).

    Args:
        content: The text content to save (documentation, notes, code snippets, etc.)
        project_id: ID of the project to save context to
        source: Optional source identifier (e.g., "meeting_notes", "documentation")

    Returns:
        Success message with context ID and linked chunk IDs (tags)
    """
    try:
        auth_token = get_auth_token()
        result = api.add_context(
            auth_token=auth_token,
            content=content,
            project_id=project_id,
            source=source
        )

        output = f"‚úÖ Context saved successfully!\n"
        output += f"Context ID: {result['context_id']}\n"
        output += f"Project: {project_id}\n"

        # Show linked chunks (tags)
        if result.get('tags'):
            output += f"Linked to {len(result['tags'])} similar chunk(s): {', '.join(result['tags'])}\n"
        else:
            output += "No similar chunks found (this might be the first chunk or similarity too low)\n"

        return output
    except Exception as e:
        return f"‚ùå Failed to save context: {str(e)}"


@mcp.tool()
def retrieve_relevant_context(
    query: str,
    project_id: str,
    limit: int = 5,
    similarity_threshold: float = 0.01
) -> str:
    """
    Retrieve relevant context from a project using semantic search.
    
    Args:
        query: What you're looking for (question, topic, or keywords)
        project_id: ID of the project to search in
        limit: Maximum number of results to return (default: 5)
        similarity_threshold: Minimum similarity score 0-1 (default: 0.7, higher = more strict)
    
    Returns:
        Formatted list of relevant context chunks with similarity scores
    """
    try:
        auth_token = get_auth_token()
        results = api.retrieve_relevant_context(
            auth_token=auth_token,
            query=query,
            project_id=project_id,
            limit=limit,
            similarity_threshold=similarity_threshold
        )
        
        if not results:
            return f"No relevant context found for query: '{query}'\nTry lowering the similarity_threshold or adding more context to the project."
        
        output = f"üîç Found {len(results)} relevant result(s) for: '{query}'\n\n"
        
        for i, result in enumerate(results, 1):
            score = result['similarity_score']
            content = result['content']
            metadata = result.get('metadata', {})
            
            output += f"{i}. [Score: {score:.3f}] "
            
            if metadata.get('source'):
                output += f"(Source: {metadata['source']})\n"
            else:
                output += "\n"
            
            # Show content preview
            if len(content) > 300:
                output += f"{content[:300]}...\n"
            else:
                output += f"{content}\n"
            
            if metadata.get('tags'):
                output += f"Tags: {', '.join(metadata['tags'])}\n"
            
            output += "\n"
        
        return output
    except Exception as e:
        return f"‚ùå Failed to retrieve context: {str(e)}"
    
from starlette.requests import Request
from starlette.responses import PlainTextResponse

async def healthcheck(req: Request):
    """Simple healthcheck endpoint"""
    return PlainTextResponse("MCP Server is running!", status_code=200)

mcp.custom_route(path="/health", methods=["GET", "POST"])(healthcheck)

if __name__ == "__main__":
    mcp.run(transport='streamable-http', host='0.0.0.0', port=8001)